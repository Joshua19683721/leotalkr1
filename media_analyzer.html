<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å¤šåª’é«”åˆ†æåŠ©æ‰‹ (Nemotron-12B)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .markdown-body {
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
        }
        .markdown-body h1, .markdown-body h2, .markdown-body h3 { margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; }
        .markdown-body h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        .markdown-body h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        .markdown-body p { margin-top: 0; margin-bottom: 16px; }
        .markdown-body code { padding: .2em .4em; margin: 0; font-size: 85%; background-color: #f6f8fa; border-radius: 6px; }
        .markdown-body pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f6f8fa; border-radius: 6px; }
        .markdown-body ul, .markdown-body ol { padding-left: 2em; margin-bottom: 16px; }
        .markdown-body blockquote { padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; margin: 0 0 16px 0; }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg overflow-hidden">
        
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-indigo-700 p-6 text-white">
            <h1 class="text-3xl font-bold">AI å¤šåª’é«”æ·±åº¦è§£æåŠ©æ‰‹</h1>
            <p class="mt-2 opacity-90">ä½¿ç”¨ nvidia/nemotron-nano-12b-v2-vl:free æ¨¡å‹é€²è¡Œåœ–åƒèˆ‡å½±ç‰‡åˆ†æ</p>
        </div>

        <div class="p-6 space-y-6">
            
            <!-- Settings Section -->
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    è¨­å®š
                </h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">OpenRouter API Key</label>
                        <input type="password" id="apiKey" placeholder="sk-or-..." class="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition" value="">
                        <div class="flex items-center mt-2">
                            <input type="checkbox" id="saveKeyCheckbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                            <label for="saveKeyCheckbox" class="ml-2 block text-sm text-gray-900">
                                è¨˜ä½ API Key (å­˜æ–¼ç€è¦½å™¨æœ¬åœ°)
                            </label>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">æ¨¡å‹ (Model)</label>
                        <input type="text" id="modelName" value="nvidia/nemotron-nano-12b-v2-vl:free" class="w-full p-2 border border-gray-300 rounded bg-gray-100 text-gray-600" readonly>
                    </div>
                </div>
            </div>

            <!-- Webcam Section -->
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <h2 class="text-lg font-semibold mb-3 text-gray-700 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    å³æ™‚æ”å½±é¡é ­ (Live Camera)
                </h2>
                <div class="space-y-4">
                    <div class="relative bg-black rounded-lg overflow-hidden aspect-video max-w-lg mx-auto">
                        <video id="webcamVideo" class="w-full h-full object-contain" autoplay playsinline muted></video>
                        <div id="cameraStatus" class="absolute top-2 right-2 bg-red-600 text-white text-xs px-2 py-1 rounded hidden animate-pulse">
                            â— éŒ„å½±ä¸­ (æ¯30ç§’åˆ†æ)
                        </div>
                    </div>
                    <div class="flex flex-wrap justify-center gap-4">
                        <button id="startCamBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition">
                            é–‹å•Ÿé¡é ­
                        </button>
                        <button id="switchCamBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition hidden">
                            åˆ‡æ›é¡é ­
                        </button>
                        <button id="startLoopBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            é–‹å§‹è‡ªå‹•å¾ªç’°åˆ†æ (æ¯30ç§’)
                        </button>
                        <button id="stopLoopBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition hidden">
                            åœæ­¢å¾ªç’°
                        </button>
                    </div>
                    
                    <div class="flex items-center justify-center mt-2">
                        <label class="flex items-center cursor-pointer select-none">
                            <div class="relative">
                                <input type="checkbox" id="powerSavingCheckbox" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                            </div>
                            <span class="ms-3 text-sm font-medium text-gray-700">çœé›»æ¨¡å¼ (æš«åœç•«é¢æ¸²æŸ“)</span>
                        </label>
                    </div>

                    <div id="countdownTimer" class="text-center text-gray-500 font-mono hidden">ä¸‹æ¬¡åˆ†æ: <span id="timeLeft">30</span>s</div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="space-y-4">
                <div class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:bg-gray-50 transition relative" id="dropZone">
                    <input type="file" id="fileInput" class="hidden" accept="image/*,video/*" multiple>
                    <div class="space-y-2 pointer-events-none">
                        <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                        <p class="text-gray-600">é»æ“Šä¸Šå‚³ï¼Œæ‹–æ”¾æ–‡ä»¶ï¼Œæˆ–ç›´æ¥ <span class="font-bold text-blue-600">è²¼ä¸Š (Ctrl+V)</span> åœ–ç‰‡</p>
                        <p class="text-xs text-gray-500">æ”¯æ´åœ–ç‰‡ (JPG, PNG) èˆ‡ å½±ç‰‡ (MP4, WebM)</p>
                    </div>
                </div>

                <div class="flex items-center space-x-2">
                    <span class="text-gray-500 text-sm font-medium">æˆ–è¼¸å…¥å½±ç‰‡é€£çµ:</span>
                    <input type="url" id="urlInput" placeholder="https://example.com/video.mp4" class="flex-1 p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 outline-none">
                    <button id="loadUrlBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded transition">è¼‰å…¥é€£çµ</button>
                </div>
            </div>

            <!-- Preview Area -->
            <div id="previewArea" class="hidden space-y-4">
                <h3 class="text-md font-semibold text-gray-700">é è¦½å…§å®¹</h3>
                <div id="mediaContainer" class="flex flex-wrap gap-4 justify-center bg-black/5 p-4 rounded-lg min-h-[100px] items-center">
                    <!-- Images/Videos will be injected here -->
                </div>
                <div id="videoFramesInfo" class="hidden text-sm text-blue-600 bg-blue-50 p-2 rounded">
                    <span class="font-bold">æç¤º:</span> å·²è‡ªå‹•å¾å½±ç‰‡ä¸­æ“·å–é—œéµå½±æ ¼ç”¨æ–¼åˆ†æã€‚
                </div>
            </div>

            <!-- Action Area -->
            <button id="analyzeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transform hover:-translate-y-0.5 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                é–‹å§‹ AI æ·±åº¦åˆ†æ
            </button>

            <!-- Result Area -->
            <div id="resultSection" class="hidden">
                <div class="border-t border-gray-200 pt-6">
                    <h2 class="text-xl font-bold mb-4 text-gray-800 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg>
                        åˆ†æçµæœ
                    </h2>
                    <div id="loadingIndicator" class="hidden flex flex-col items-center justify-center py-8">
                        <div class="loading-spinner mb-4"></div>
                        <p class="text-gray-600 animate-pulse">æ­£åœ¨èª¿ç”¨å¤§æ¨¡å‹é€²è¡Œæ·±åº¦è§£è®€ï¼Œè«‹ç¨å€™...</p>
                    </div>
                    <div id="outputContent" class="markdown-body bg-white p-6 rounded-lg border border-gray-200 shadow-sm min-h-[200px]">
                        <!-- Markdown result will appear here -->
                    </div>
                </div>
            </div>

        </div>
        
        <!-- Footer -->
        <div class="bg-gray-100 p-4 text-center text-gray-500 text-sm">
            Powered by OpenRouter & Nvidia Nemotron
        </div>
    </div>

    <!-- Hidden video element for frame extraction -->
    <video id="hiddenVideo" class="hidden" crossorigin="anonymous" playsinline muted></video>
    <canvas id="hiddenCanvas" class="hidden"></canvas>

    <script>
        // DOM Elements
        const apiKeyInput = document.getElementById('apiKey');
        const saveKeyCheckbox = document.getElementById('saveKeyCheckbox');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        const previewArea = document.getElementById('previewArea');
        const mediaContainer = document.getElementById('mediaContainer');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const resultSection = document.getElementById('resultSection');
        const outputContent = document.getElementById('outputContent');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const videoFramesInfo = document.getElementById('videoFramesInfo');
        const hiddenVideo = document.getElementById('hiddenVideo');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const webcamVideo = document.getElementById('webcamVideo');
        const startCamBtn = document.getElementById('startCamBtn');
        const switchCamBtn = document.getElementById('switchCamBtn');
        const startLoopBtn = document.getElementById('startLoopBtn');
        const stopLoopBtn = document.getElementById('stopLoopBtn');
        const cameraStatus = document.getElementById('cameraStatus');
        const countdownTimer = document.getElementById('countdownTimer');
        const timeLeftSpan = document.getElementById('timeLeft');
        const powerSavingCheckbox = document.getElementById('powerSavingCheckbox');

        // State
        let mediaItems = []; // Array of { type: 'image'|'video', content: base64, originalFile: fileObj }
        let extractedFrames = []; // Array of base64 strings for analysis
        let autoLoopInterval = null;
        let countdownInterval = null;
        let ttsQueue = [];
        let ttsActive = false;

        // Load API Key from local storage
        const savedKey = localStorage.getItem('openrouter_api_key');
        if (savedKey) {
            apiKeyInput.value = savedKey;
            saveKeyCheckbox.checked = true;
        }

        // Save API Key on change
        apiKeyInput.addEventListener('input', () => {
            if (saveKeyCheckbox.checked) {
                localStorage.setItem('openrouter_api_key', apiKeyInput.value);
            }
        });

        saveKeyCheckbox.addEventListener('change', () => {
            if (saveKeyCheckbox.checked) {
                localStorage.setItem('openrouter_api_key', apiKeyInput.value);
            } else {
                localStorage.removeItem('openrouter_api_key');
            }
        });

        // Event Listeners for Drag & Drop
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('bg-blue-50', 'border-blue-400');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('bg-blue-50', 'border-blue-400');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('bg-blue-50', 'border-blue-400');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        // Paste Event
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            const files = [];
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    files.push(items[i].getAsFile());
                }
            }
            if (files.length > 0) handleFiles(files);
        });

        // URL Load
        loadUrlBtn.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) processVideoUrl(url);
        });

        // Analyze Button
        analyzeBtn.addEventListener('click', startAnalysis);

        // Webcam Logic
        let currentStream = null;
        let videoDevices = [];
        let currentDeviceIndex = 0;

        async function startCamera(deviceId = null) {
            // Stop current stream if any
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: deviceId 
                    ? { deviceId: { exact: deviceId } } 
                    : { facingMode: { ideal: "environment" } }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                webcamVideo.srcObject = stream;
                
                startCamBtn.classList.add('hidden');
                startLoopBtn.disabled = false;

                // Enumerate devices to enable switching
                const devices = await navigator.mediaDevices.enumerateDevices();
                videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length > 1) {
                    switchCamBtn.classList.remove('hidden');
                    // Update index based on current active device
                    const currentTrack = stream.getVideoTracks()[0];
                    const currentDeviceId = currentTrack.getSettings().deviceId;
                    currentDeviceIndex = videoDevices.findIndex(d => d.deviceId === currentDeviceId);
                    if (currentDeviceIndex === -1) currentDeviceIndex = 0;
                }
            } catch (err) {
                console.error("Error accessing webcam:", err);
                alert("ç„¡æ³•å­˜å–æ”å½±æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®šã€‚");
            }
        }

        startCamBtn.addEventListener('click', async () => {
            await startCamera();
        });

        switchCamBtn.addEventListener('click', async () => {
            if (videoDevices.length < 2) return;
            currentDeviceIndex = (currentDeviceIndex + 1) % videoDevices.length;
            await startCamera(videoDevices[currentDeviceIndex].deviceId);
        });

        startLoopBtn.addEventListener('click', () => {
            startLoopBtn.classList.add('hidden');
            stopLoopBtn.classList.remove('hidden');
            cameraStatus.classList.remove('hidden');
            countdownTimer.classList.remove('hidden');
            
            // Immediate capture first
            captureAndAnalyze();
            
            // Start interval
            let timeLeft = 30;
            timeLeftSpan.innerText = timeLeft;
            
            countdownInterval = setInterval(() => {
                timeLeft--;
                timeLeftSpan.innerText = timeLeft;
                if (timeLeft <= 0) timeLeft = 30;
            }, 1000);

            autoLoopInterval = setInterval(() => {
                captureAndAnalyze();
                timeLeft = 30;
                timeLeftSpan.innerText = timeLeft;
            }, 30000);
        });

        stopLoopBtn.addEventListener('click', () => {
            stopLoopBtn.classList.add('hidden');
            startLoopBtn.classList.remove('hidden');
            cameraStatus.classList.add('hidden');
            countdownTimer.classList.add('hidden');
            
            clearInterval(autoLoopInterval);
            clearInterval(countdownInterval);
            autoLoopInterval = null;
            countdownInterval = null;
        });

        async function captureAndAnalyze() {
            if (!webcamVideo.srcObject) return;

            // Flash effect
            webcamVideo.classList.add('opacity-50');
            setTimeout(() => webcamVideo.classList.remove('opacity-50'), 200);

            // Capture frame
            hiddenCanvas.width = webcamVideo.videoWidth;
            hiddenCanvas.height = webcamVideo.videoHeight;
            const ctx = hiddenCanvas.getContext('2d');
            ctx.drawImage(webcamVideo, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
            const dataUrl = hiddenCanvas.toDataURL('image/jpeg', 0.8);

            // Reset state and prepare for single image analysis
            resetState();
            extractedFrames = [dataUrl];
            
            // We don't need to show preview for auto-loop, result is enough? 
            // Or maybe show the captured frame in preview area?
            // Let's show it so user knows what's being analyzed.
            mediaItems.push({ type: 'image', content: dataUrl });
            updatePreview();

            // Analyze
            await startAnalysis(true); // true = auto mode
        }

        // --- Core Functions ---

        async function handleFiles(files) {
            if (!files.length) return;
            
            // Clear previous items if single analysis mode (or keep appending? let's reset for simplicity)
            resetState();

            for (let file of files) {
                if (file.type.startsWith('image/')) {
                    await processImageFile(file);
                } else if (file.type.startsWith('video/')) {
                    await processVideoFile(file);
                }
            }
            updatePreview();
            
            // Auto-start analysis if API key is present
            if (apiKeyInput.value.trim()) {
                startAnalysis();
            }
        }

        function resetState() {
            mediaItems = [];
            extractedFrames = [];
            mediaContainer.innerHTML = '';
            outputContent.innerHTML = '';
            resultSection.classList.add('hidden');
            videoFramesInfo.classList.add('hidden');
            previewArea.classList.add('hidden');
        }

        function processImageFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    mediaItems.push({ type: 'image', content: e.target.result });
                    // For images, the content itself is what we send
                    extractedFrames.push(e.target.result); 
                    resolve();
                };
                reader.readAsDataURL(file);
            });
        }

        async function processVideoFile(file) {
            const url = URL.createObjectURL(file);
            await extractFramesFromVideo(url, true); // true = revoke url after
        }

        async function processVideoUrl(url) {
            resetState();
            // Check if it looks like a video file
            if (url.match(/\.(mp4|webm|ogg)$/i) || url.startsWith('blob:')) {
                await extractFramesFromVideo(url, false);
            } else {
                // Fallback: Just display it and hope the user knows the model might not see it unless we screen capture?
                // Actually, for YouTube etc, we can't easily get frames client side due to CORS.
                // We will treat it as a "Link Analysis" task if we can't load it.
                // But for now, let's try to load it in video tag.
                await extractFramesFromVideo(url, false);
            }
            updatePreview();

            // Auto-start analysis if API key is present
            if (apiKeyInput.value.trim()) {
                startAnalysis();
            }
        }

        async function extractFramesFromVideo(videoUrl, revokeUrl) {
            return new Promise((resolve, reject) => {
                // Handle CORS for local vs remote
                // python -m http.server does not support CORS headers by default, so requesting with crossorigin='anonymous'
                // for same-origin resources will fail because the server won't return the required ACAO header.
                // We should only use crossorigin if the domain is different.
                try {
                    const urlObj = new URL(videoUrl, window.location.href);
                    if (urlObj.origin === window.location.origin) {
                        hiddenVideo.removeAttribute('crossorigin');
                    } else {
                        hiddenVideo.setAttribute('crossorigin', 'anonymous');
                    }
                } catch (e) {
                    // If invalid URL (e.g. blob:), it's likely safe/local or handles itself
                    hiddenVideo.removeAttribute('crossorigin');
                }

                hiddenVideo.src = videoUrl;
                hiddenVideo.currentTime = 1; // Start slightly in
                
                // Add to media items for preview
                mediaItems.push({ type: 'video', content: videoUrl });

                let framesCaptured = 0;
                const targetFrames = 3;
                const captures = [];

                const onSeeked = () => {
                    // Draw to canvas
                    hiddenCanvas.width = hiddenVideo.videoWidth;
                    hiddenCanvas.height = hiddenVideo.videoHeight;
                    const ctx = hiddenCanvas.getContext('2d');
                    ctx.drawImage(hiddenVideo, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                    
                    // Compress to jpeg
                    const dataUrl = hiddenCanvas.toDataURL('image/jpeg', 0.7);
                    captures.push(dataUrl);
                    framesCaptured++;

                    if (framesCaptured < targetFrames) {
                        // Seek to next position (30%, 60%, 90%)
                        const nextTime = hiddenVideo.duration * ((framesCaptured + 1) * 0.3);
                        if (nextTime < hiddenVideo.duration) {
                            hiddenVideo.currentTime = nextTime;
                        } else {
                            finish();
                        }
                    } else {
                        finish();
                    }
                };

                const finish = () => {
                    hiddenVideo.removeEventListener('seeked', onSeeked);
                    extractedFrames.push(...captures);
                    videoFramesInfo.classList.remove('hidden');
                    if (revokeUrl) URL.revokeObjectURL(videoUrl);
                    resolve();
                };

                hiddenVideo.addEventListener('loadedmetadata', () => {
                    if(hiddenVideo.duration === Infinity || isNaN(hiddenVideo.duration)) {
                        // Streaming or unknown duration, just take one frame
                        hiddenVideo.currentTime = 0;
                    } else {
                        hiddenVideo.currentTime = hiddenVideo.duration * 0.1;
                    }
                });

                hiddenVideo.addEventListener('seeked', onSeeked);
                
                const urlObj = new URL(videoUrl, window.location.href);
                
                hiddenVideo.addEventListener('error', (e) => {
                    console.error('Video Error:', hiddenVideo.error);
                    let msg = "ç„¡æ³•è¼‰å…¥å½±ç‰‡ã€‚";
                    if (hiddenVideo.error && hiddenVideo.error.code === 4) {
                         msg += " (æ ¼å¼ä¸æ”¯æ´æˆ–ä¾†æºç„¡æ³•å­˜å–)";
                    } else if (urlObj && urlObj.origin !== window.location.origin) {
                        msg += " å¯èƒ½æ¶‰åŠè·¨åŸŸ (CORS) å•é¡Œï¼Œè«‹ç¢ºä¿è©²å½±ç‰‡ä¼ºæœå™¨å…è¨±è·¨åŸŸå­˜å–ã€‚";
                    }
                    alert(msg + "\n\nå»ºè­°: è«‹å˜—è©¦ä¸‹è¼‰è©²å½±ç‰‡ä¸¦ä½¿ç”¨ã€Œæ‹–æ”¾ä¸Šå‚³ã€åŠŸèƒ½ã€‚");
                    resolve(); // Resolve anyway to not break flow
                });
            });
        }

        function updatePreview() {
            if (mediaItems.length > 0) {
                previewArea.classList.remove('hidden');
                mediaContainer.innerHTML = '';
                mediaItems.forEach(item => {
                    if (item.type === 'image') {
                        const img = document.createElement('img');
                        img.src = item.content;
                        img.className = 'h-48 object-contain rounded border border-gray-300';
                        mediaContainer.appendChild(img);
                    } else if (item.type === 'video') {
                        const vid = document.createElement('video');
                        vid.src = item.content;
                        vid.controls = true;
                        vid.className = 'h-48 max-w-full rounded border border-gray-300';
                        mediaContainer.appendChild(vid);
                    }
                });
            }
        }

        async function startAnalysis(isAuto = false) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                alert('è«‹è¼¸å…¥ OpenRouter API Key');
                // Stop loop if no key
                if (autoLoopInterval) stopLoopBtn.click();
                return;
            }
            if (extractedFrames.length === 0) {
                if (!isAuto) alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡æˆ–å½±ç‰‡');
                return;
            }

            resultSection.classList.remove('hidden');
            loadingIndicator.classList.remove('hidden');
            outputContent.innerHTML = '';
            analyzeBtn.disabled = true;

            try {
                const model = document.getElementById('modelName').value;
                
                // Construct payload
                const content = [
                    {
                        type: "text",
                        text: `Please analyze the image and provide a JSON response (without markdown code blocks) with the following structure:
{
  "english_sentence": "A simple KET A2 level English sentence (10-20 words) describing the image.",
  "chinese_translation": "The Traditional Chinese (ç¹é«”ä¸­æ–‡) translation of the above sentence.",
  "analysis": {
    "vocabulary": "List key A2 vocabulary used (e.g. 'Park: a public garden'). Use Traditional Chinese for explanations.",
    "grammar": "Explain the grammar point. Use Traditional Chinese for explanations.",
    "scenario": "Describe the scenario/context suitable for KET speaking. Use Traditional Chinese.",
    "tips": "One tip for KET exam preparation related to this image. Use Traditional Chinese."
  }
}
Ensure the content is strictly KET A2 level and all Chinese text is in Traditional Chinese (ç¹é«”ä¸­æ–‡).`
                    }
                ];

                // Add images
                extractedFrames.forEach(frameData => {
                    content.push({
                        type: "image_url",
                        image_url: {
                            url: frameData
                        }
                    });
                });

                const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${apiKey}`,
                        "Content-Type": "application/json",
                        "HTTP-Referer": window.location.href, // Required by OpenRouter
                        "X-Title": "Media Analyzer Tool"
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            {
                                role: "user",
                                content: content
                            }
                        ]
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error?.message || 'API Request failed');
                }

                const data = await response.json();
                console.log('API Response:', data);

                if (!data.choices || data.choices.length === 0) {
                    throw new Error('API è¿”å›äº†æ„å¤–çš„æ ¼å¼ï¼ˆç¼ºå°‘ choices å­—æ®µï¼‰ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°æ—¥èªŒä»¥ç²å–æ›´å¤šè©³æƒ…ã€‚\n\nå®Œæ•´éŸ¿æ‡‰: ' + JSON.stringify(data, null, 2));
                }

                const responseData = data.choices[0].message.content;
                let parsedData;
                try {
                    // Improved JSON extraction: find the first '{' and last '}'
                    const firstBrace = responseData.indexOf('{');
                    const lastBrace = responseData.lastIndexOf('}');
                    
                    let jsonStr;
                    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                         jsonStr = responseData.substring(firstBrace, lastBrace + 1);
                    } else {
                         // Fallback to basic cleaning if braces not found
                         jsonStr = responseData.replace(/```json/g, '').replace(/```/g, '').trim();
                    }
                    
                    parsedData = JSON.parse(jsonStr);
                } catch (e) {
                    console.error("JSON Parse Error", e);
                    // Fallback if not JSON
                    parsedData = {
                        english_sentence: responseData,
                        chinese_translation: "è§£æå¤±æ•—ï¼Œè«‹é‡è©¦ã€‚",
                        analysis: { vocabulary: "", grammar: "", scenario: "", tips: "" }
                    };
                }

                // Render UI
                const html = `
                    <div class="space-y-6">
                        <div class="bg-blue-50 p-6 rounded-xl border border-blue-100">
                            <h3 class="text-sm font-bold text-blue-500 uppercase tracking-wide mb-2">English Description (KET A2)</h3>
                            <p class="text-2xl text-gray-800 font-medium leading-relaxed">${parsedData.english_sentence}</p>
                            
                            <div class="mt-4 pt-4 border-t border-blue-200">
                                <h3 class="text-sm font-bold text-gray-500 uppercase tracking-wide mb-1">ä¸­æ–‡ç¿»è­¯</h3>
                                <p class="text-lg text-gray-700">${parsedData.chinese_translation}</p>
                            </div>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition">
                                <h4 class="font-bold text-purple-600 mb-2 flex items-center">ğŸ“š é‡é»å–®å­— (Vocabulary)</h4>
                                <p class="text-gray-600 text-sm">${parsedData.analysis.vocabulary}</p>
                            </div>
                            <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition">
                                <h4 class="font-bold text-green-600 mb-2 flex items-center">âš–ï¸ æ–‡æ³•è§£æ (Grammar)</h4>
                                <p class="text-gray-600 text-sm">${parsedData.analysis.grammar}</p>
                            </div>
                            <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition">
                                <h4 class="font-bold text-orange-600 mb-2 flex items-center">ğŸ­ é©ç”¨æƒ…å¢ƒ (Scenario)</h4>
                                <p class="text-gray-600 text-sm">${parsedData.analysis.scenario}</p>
                            </div>
                            <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition">
                                <h4 class="font-bold text-red-600 mb-2 flex items-center">ğŸ’¡ å‚™è€ƒæŠ€å·§ (Exam Tips)</h4>
                                <p class="text-gray-600 text-sm">${parsedData.analysis.tips}</p>
                            </div>
                        </div>
                    </div>
                `;
                
                outputContent.innerHTML = html;
                
                // Add Speak Button
                const speakBtn = document.createElement('button');
                speakBtn.className = "mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-full shadow flex items-center mx-auto transition transform hover:scale-105";
                speakBtn.innerHTML = `<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"></path></svg> å†æ¬¡æœ—è®€è‹±æ–‡`;
                speakBtn.onclick = () => speakText(parsedData.english_sentence);
                outputContent.appendChild(speakBtn);

                // Auto speak English only
                speakText(parsedData.english_sentence);

            } catch (error) {
                console.error(error);
                outputContent.innerHTML = `<div class="text-red-600 bg-red-50 p-4 rounded overflow-auto"><p class="font-bold">ç™¼ç”ŸéŒ¯èª¤:</p><pre class="whitespace-pre-wrap text-xs mt-2">${error.message}</pre></div>`;
            } finally {
                loadingIndicator.classList.add('hidden');
                analyzeBtn.disabled = false;
            }
        }

        function speakText(text) {
            if (!('speechSynthesis' in window)) {
                alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³åˆæˆåŠŸèƒ½ã€‚");
                return;
            }

            // Remove Chinese characters and Chinese punctuation to ensure only English is spoken
            // \u4e00-\u9fa5: CJK Unified Ideographs (Common Chinese characters)
            // \u3000-\u303f: CJK Symbols and Punctuation (e.g., ã€‚, ï¼Œ, ã€)
            // \uff00-\uffef: Halfwidth and Fullwidth Forms (e.g., fullwidth punctuation ï¼)
            const cleanText = text.replace(/[\u4e00-\u9fa5\u3000-\u303f\uff00-\uffef]/g, '').trim();

            if (!cleanText) return;

            ttsQueue.push(cleanText);
            if (!ttsActive) {
                const next = () => {
                    if (ttsQueue.length === 0) {
                        ttsActive = false;
                        return;
                    }
                    ttsActive = true;
                    const t = ttsQueue.shift();
                    const utterance = new SpeechSynthesisUtterance(t);
                    utterance.lang = 'en-US';
                    utterance.rate = 0.9;
                    utterance.onend = () => {
                        ttsActive = false;
                        next();
                    };
                    utterance.onerror = () => {
                        ttsActive = false;
                        next();
                    };
                    window.speechSynthesis.speak(utterance);
                };
                next();
            }
        }
    </script>
</body>
</html>
